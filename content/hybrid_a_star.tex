\section{Hybrid A* Search}
As described in \fref{sec:HA} the hybrid A* (HA*) search expands vertices in continuous rather than discrete space. Even though it works in continuous space, HA* uses a discretized description of the world by pruning search branches that have similar leaf states. This is done in order to avoid growth of similar branches that add only very little to the solution, but vastly increase the size of the search graph.

A state is characterized by $\bldx = (x, y, \theta)$, where $x$ and $y$ denote the position and $\theta$ the heading of the vertex respectively. The action set $U$ for a given vertex $x$ can take any shape\footnote{An opposing method is to use a state lattice, where a large amount of motion primitives connect cells always in a predefined manner.}. In order to adhere to the constraints imposed by a non-holonomic vehicle, a vertex is expanded by one of three actions; maximum steering left, maximum steering right as well as no steering. Each of this control actions is applied for a certain amount of time, resulting in an arc of a circle with a lower bound turning radius based on the vehicle constraints. This will ensure that the resulting paths are always drivable, as the actual vehicle model is used to expand vertices, even though they might result in excessive steering actions.

HA* does not take the velocity of the vehicle into account, but based on the solution of HA* an appropriate velocity profile can easily be calculated.

To incorporate the heading of the vehicle a finite three dimensional cuboid, which represents all possible states of the vehicle is used. During the expansions of vertices with the actions $u \in U(x)$ new states are generated. If a new state falls into a grid cell that is already occupied with another vertex and the new vertex has a lower \textit{cost-so-far} the old vertex gets pruned (deleted). The search continues until a vertex reaches the goal grid cell, or all reachable cells have been reached and thus the open list is empty.

\subsection{Vertex Expansion and Branch Pruning}
The search starts with the current state of the vehicle, denoted as $x_s$. HA* will generate six successor vertices; three driving forward as well as three driving reverse. The successors are generated by using arcs with the minimum turning radius of the vehicle\footnote{The arc length used for the expansion can be chosen arbitrarily, however a shorter length promises higher levels of resolution completeness, as the likelihood to reach each state is increasing.}. The cost for the state transition are based on the length of the arc. Additional costs are accrued for changing driving directions, driving in reverse; and turning, as opposed to going straight. The penalty for turning as well as driving in reverse are multiplicative (depend on portion of the path turning or reversing), while the penalty for the change of driving directions is constant.

For each successor the following actions will be executed. If the successor vertex reaches a cell of the three dimensional cuboid that is not part of the closed list (meaning that cell has not yet been expanded) the evaluation continues. If the cell is not part of the open list (meaning the cell has not been reached prior by any other vertex expansion) or the \textit{cost-so-far} from the predecessor vertex plus the cost for the vertex expansion to the successor reaching the cell is lower than the \textit{cost-so-far} of the vertex currently associated with that cell, then the new vertex will be assigned a pointer to its predecessor, the sum of the \textit{cost-so-far} from its predecessor plus the cost for the expansion will be assigned to its $g$-value and the \textit{cost-to-come} will be estimated using the heuristics and assigned to its $h$-value. If the a vertex with the same cell as the successor is on the closed or the open list and the successor's $g$-value is not lower, then the successor will be discarded, the branch will get pruned.

In case the arc length is shorter than the square root of the cell area, a vertex expansion can result in the successor arriving in the same cell. 
If this happens, it is insufficient to compare the vertices based on their \textit{cost-so-far} as the cost of the new vertex will always be higher. Thus the comparison is based on the total estimated cost for both vertices. Since the algorithm is using consistent heuristics this leads to the effect, that the optimistic estimate will make vertices that are closer to the goal more expensive\footnote{The total estimated cost of a vertex $x$ is $f(x) = g(x)+h(x)$ and the successor cost $f(x) = g(x) + l(x,u)  + h(x_{succ}) $ using a consistent heuristic implies $ h(x) \leq  l(x,u)  + h(x_{succ}$}, hence a tie breaker is added to the predecessor to account for the consistent nature of the heuristic.\Fref{alg:sameCellExpansion} illustrates this process. If the successor vertex is more expensive it will be discarded and the algorithm proceeds.

\begin{algorithm}
\caption{Same Cell Expansion}\label{alg:sameCellExpansion}
    \begin{algorithmic}[1]
                \For {$u \in U(x)$}
                \State $x_{succ} \gets f(x,u)$
                    \If {$\neg exists(x_{succ},C)$}
                        \If {$RoundState(x) = RoundState(x_{succ})$}
	                        \If {$ f(x_{succ}) > f(x_{x}) + tieBreaker$}
		                        \State \textbf{delete} $x_{succ}$
                        		 \State \textbf{continue}
        	                \EndIf            
            	                \State $Pred(x_{succ}) \gets x$
                	            \State $g(x_{succ}) \gets g$
                    	        \State $h(x_{succ}) \gets Heuristic(x_{succ}, x_g)$
                        	    \If {$\neg exists(x_{succ},O)$}
                            	    \State $O.push(x_{succ})$
                           		\Else
                                	\State $O.decreaseKey(x_{succ})$
                        \EndIf
                        \EndIf
                    \EndIf
                \EndFor
    \end{algorithmic}
\end{algorithm}

\begin{figure}[h]
    \includegraphicsTex{MF.eps_tex}
    \caption{Vertex expansion and pruning}
    \label{fig:expansionPruning}
\end{figure}

\subsection{Optimal Solution Probing}
The HA* planner sporadically calculates Dubins curves from vertices currently being expanded to the goal. This is done partly as the exact continuous goal location is not reachable by the discretized control actions alone and in order to increase search speed. The calculated path is checked for collisions with the environment, if none exist the search terminates. In order to reduce computational load it is not beneficial to probe for optimal solutions from each vertex, but rather every n-th iteration. Furthermore it is more reasonable to do so when approaching the goal or in a very obstacle sparse environment, as the likelihood for a collision is high otherwise, making this an expensive operation with little chance to payoff.

\subsection{Collision Checking}
While there are many ways to determine whether a configuration of the vehicle is collision free, $q \in \calC_{free}$. The spatial occupancy enumeration approach presented in \fref{sec:spatialOccupancyEnumeration} is used for collision checking. In order to make this a viable solution it is mandatory to precompute possible configurations of the vehicle and save these in a lookup table. The advantage of this approach is that the collision checking can be conducted rapidly in constant time for any configuration of the vehicle.

As the lookup can easily be translated to a specific two dimensional cell with integer coordinates for $x$ and $y$, only the different possible headings need to be taken into account. In order to compute spatial occupancy of a shape denoted by its corner points Bresenham's line algorithm can be used, but it does not correctly occupies all cells that the line between two points intersects with. For collision checking however, there needs to be certainty, thus a ray tracing algorithm described in \cite{Amanatides.2011} is used, that correctly marks all cells the line intersects with.

Once the basic bounding box is computed the lookup table gets filled with the spatial occupancy of the vehicle while rotating it with the $\theta$ discretization steps. In order to account for the hybrid nature of HA*, and the fact, that the vehicle, can reach any position within a cell, the spatial occupancy is also precomputed for 100 different positions within the grid cell.

\section{Heuristics}
While the goal is to produce drivable solutions that are approaching the optimum, it is important to make use of A* being an informed search, implementing heuristics allowing the algorithm converge quickly towards the solution. HA* is using estimates from two heuristics. As both of the heuristics are admissible the maximum of the two is chosen for any given state. The two heuristics capture very different parts of the problem; the constrained heuristic incorporates the restrictions of the vehicle, ignoring the environment, while the unconstrained heuristic disregards the vehicle's constraints and only accounts for obstacles.

\subsection{Constrained Heuristic}
The constrained heuristic takes the characteristics of the vehicle into account, while neglecting the environment. Suitable candidates are either Dubins or Reeds-Shepp curves. These curves introduced in \fref{sec:differentialConstraints} are the paths of minimal length with an upper bound curvature for the forward and the forward as well as backward driving car respectively.

Since this heuristic takes the current heading as well as the turning radius into account it ensures, that the vehicle approaches the goal with the correct heading. This is especially important, when the car gets closer to the goal. For perfomance reasons this heuristic can be precomputed and stored in a lookup table. This is possible since it ignores obstacles and hence does not require any environment information. To precompute the heuristic estimate values the curves of minimal length are calculated in a discretized neighborhood of the goal.

Given that both Dubins as well as Reeds-Shepp curves are minimal, this heuristic is clearly admissible.

\subsection{Unconstrained Heuristic}
The unconstrained heuristic neglects the characteristics of the vehicle and only accounts for obstacles. The estimate is based on the shortest distance between the goal node and the vertex currently being expanded. This distance is determined using the standard A* search in two dimensions ($x,y$ position) with an Euclidean distance heuristic.
The two dimensional A* search uses the current vertex as the goal vertex, and the goal vertex of the HA* search as the start vertex. This is beneficial, since the closed list of 

The unconstrained heuristic guides the vehicle away from dead ends and around u-shaped obstacles.

Since HA* can reach any point in a cell the unconstrained heuristic needs to be discounted by the absolute difference of the continuous coordinate of the current and the goal vertex.

\begin{figure}[h]
    \includegraphicsTex{MF.eps_tex}
    \caption{Unconstrained and constrained heuristic for a sample configuration}
    \label{fig:heuristics}
\end{figure}